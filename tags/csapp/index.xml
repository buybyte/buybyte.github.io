<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Hextra – Csapp</title><link>https://buybyte.github.io/tags/csapp/</link><description>Recent content in Csapp on Hextra</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 20 May 2019 14:22:49 +0800</lastBuildDate><atom:link href="https://buybyte.github.io/tags/csapp/index.xml" rel="self" type="application/rss+xml"/><item><title>csapp-memory-hierarchy</title><link>https://buybyte.github.io/blog/csapp-memory-hierarchy/</link><pubDate>Mon, 20 May 2019 14:22:49 +0800</pubDate><guid>https://buybyte.github.io/blog/csapp-memory-hierarchy/</guid><description>
&lt;h1>storage&lt;/h1>&lt;h2>Disk Controller&lt;span class="hx-absolute -hx-mt-20" id="disk-controller">&lt;/span>
&lt;a href="#disk-controller" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;blockquote>
&lt;p>我们知道定位一个磁盘空间需要三个参数(platter, track, sector). 但是 cpu 不使用这么麻烦的方式, cpu 使用的是逻辑盘号. 也就是磁盘控制器将逻辑盘号翻译成 platter, track, sector. 磁盘控制器充当一个中间层. 也就是只关心逻辑盘号, 不关心具体的(platter, track, sector).
通过逻辑盘号将三维的(platter, track, sector) 转换为一维数组, 这就是抽象的意义啊. 这就是降维思维嘛.&lt;/p>
&lt;/blockquote>
&lt;h2>Memory Hierarchy&lt;span class="hx-absolute -hx-mt-20" id="memory-hierarchy">&lt;/span>
&lt;a href="#memory-hierarchy" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;blockquote>
&lt;p>我们知道不同类型的存储, 每一个 bit 的价格不一样, 元件不同, 速度也不同. 世上事情大抵如此,不会集所有优点于一身.&lt;br>
利用程序的局部性, 构造一个层次存储系统, 每一层的存储当做下一层的缓存,(也就是下一层的一部分)这才会有 hit 和 miss 的根本原因啊! 这才会引出缓存的 placement policy 和 replacement policy. 缓存这种思想和普遍, 做开发时 redis 作为数据库的缓存, 也是解决速度不匹配的问题.&lt;/p>
&lt;/blockquote></description></item></channel></rss>