<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>glibc on buybyte</title><link>http://buybyte.github.io/tags/glibc/</link><description>Recent content in glibc on buybyte</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 21 Apr 2025 15:34:28 +0800</lastBuildDate><atom:link href="http://buybyte.github.io/tags/glibc/index.xml" rel="self" type="application/rss+xml"/><item><title>Asm How Glibc Wrap Syscall</title><link>http://buybyte.github.io/2025/04/21/asm-how-glibc-wrap-syscall/</link><pubDate>Mon, 21 Apr 2025 15:34:28 +0800</pubDate><guid>http://buybyte.github.io/2025/04/21/asm-how-glibc-wrap-syscall/</guid><description>实验平台: x86_64 GNU/Linux mint22.1 使用 glibc 的函数 write1.c #include &amp;lt;unistd.h&amp;gt; int main() { const char msg[] = &amp;quot;Hello, glibc!\n&amp;quot;; write(1, msg, sizeof(msg) - 1); // glibc's write() wrapper return 0; } gcc -o write1 write1.c 使用 ltrace ./write1 查看调用了 write 库函数 不使用 glibc 的函数 write2.c #include &amp;lt;errno.h&amp;gt; #include &amp;lt;syscall.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; ssize_t</description></item></channel></rss>